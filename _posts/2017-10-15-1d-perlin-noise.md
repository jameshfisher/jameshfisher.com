---
title: "One-dimensional Perlin noise"
---

<canvas id="perlin" height="400" width="1200" style="height: 200px; width: 600px;"></canvas>
<script>
  const slopeAt = [];
  for (let i = 0; i <= 10; i++) {
    slopeAt[i] = (Math.random()*2)-1;
  }

  function samplePerlin(x) {
    const lo = Math.floor(x);
    const hi = lo+1;
    const dist = x-lo;
    loSlope = slopeAt[lo];
    hiSlope = slopeAt[hi];
    loPos = loSlope * dist;
    hiPos = -hiSlope * (1-dist);
    const u = dist * dist * (3.0 - 2.0 * dist);  // cubic curve
    return (loPos*(1-u)) + (hiPos*u);  // interpolate
  }

  const coords = [];
  for (let i = 0; i < 10; i+=0.01) {
    coords.push(i);
    coords.push(samplePerlin(i));
  }

  const canvasEl = document.getElementById("perlin");
  const gl = canvasEl.getContext("webgl");

  const coordsArray = new Float32Array(coords);
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, coordsArray, gl.STATIC_DRAW);

  gl.clearColor(0.2,0.2,0.5,1);

  function createShader(ty, src) {
    const s = gl.createShader(ty);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
    return s;
  }

  const vs = createShader(gl.VERTEX_SHADER, 'attribute vec2 coord; void main(void) { gl_Position = vec4((coord.x/5.0)-1.0, coord.y, 0.0, 1.0); }');
  const fs = createShader(gl.FRAGMENT_SHADER, 'precision mediump float; uniform vec4 color; void main(void) { gl_FragColor = color; }');

  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(prog));
  }
  gl.useProgram(prog);

  const coordLoc = gl.getAttribLocation(prog, "coord");
  gl.vertexAttribPointer(coordLoc, 2, gl.FLOAT, false, 0, 0);

  const colorLoc = gl.getUniformLocation(prog, "color");

  gl.uniform4fv(colorLoc, [1.0, 1.0, 1.0, 1.0]);

  gl.enableVertexAttribArray(coordLoc);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.LINE_STRIP, 0, coords.length/2);

  gl.uniform4fv(colorLoc, [1.0, 0.3, 0.3, 1.0]);

  for (let i = 0; i < slopeAt.length; i++) {
    const v = slopeAt[i];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      i-0.2, -v*0.2,
      i+0.2,  v*0.2,
    ]), gl.STATIC_DRAW);
    gl.drawArrays(gl.LINE_STRIP, 0, 2);
  }
</script>

Above you see a wiggly white line.
The white line is generated by joining up the red tangent lines.
These tangent lines are regularly spaced with random slopes.
This technique, apparently, is the heart of "Perlin noise".
Perlin noise is a way to make "naturalistic" random fluctuation.

```js
const slopeAt = [];
for (let i = 0; i < 10; i++) {
  slopeAt[i] = (Math.random()*2)-1;
}

function samplePerlin(x) {
  const lo = Math.floor(x);
  const hi = lo+1;
  const dist = x-lo;
  loSlope = slopeAt[lo];
  hiSlope = slopeAt[hi];
  loPos = loSlope * dist;
  hiPos = -hiSlope * (1-dist);
  const u = dist * dist * (3.0 - 2.0 * dist);  // cubic curve
  return (loPos*(1-u)) + (hiPos*u);  // interpolate
}
```

The image above is one "octave" of Perlin noise.
More realistic naturalism is generated by summing several octaves.
I'll do that in a future post.
